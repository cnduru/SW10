\section{Fault Injection and Countermeasures}
\subsection{Fault Injection}
\subsection{Countermeasures}
\paragraph{Instruction Differentiation} 
A single bitflip can change the instruction being performed by changing the opcode of an instruction being executed, e.g.\ch{find concrete opcode example}. This is particularly troublesome if the two instructions take the same number of parameters and put the same number of elements back on the operand stack. If this is the case, the operand stack will have the same number of elements on it whether the original or the altered instruction is executed, and the same number of parameters. It can therefore not be detected with e.g. a countermeasure such as Field of Bit, which detects a change in an instruction if the number of parameters change~\cite[p. 16]{javasec}\ch{fieldofbit usually implemented (source?)}.
%modification of the JVM instruction set binary representation
This can partly be remedied by modifying the underlying binary representations of the instructions in the Java Card Virtual Machine (JCVM)\ch{should this be generalised to just virtual machine since it is universally true for all virtual machines?}.
%fewer instructions with same parameter number and hamming distance 1
This would work by changing the representations in such a way that as few as possible instructions with the same number of parameters, and the same number of elements returned to the operand stack, are different by one bit. 
%not complete protection against bitflips, but improves misalignment detection rates
When a single bitflip changes an instruction, the chances that it is an undetectable change, in regards to required parameters and elements put back on the operand stack by it, are smaller than before modifying the representations.

%example table
