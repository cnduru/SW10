\section{Fault Injection and Countermeasures}
\subsection{Fault Injection}
\subsection{Countermeasures}
\paragraph{Instruction Differentiation} 
A single bitflip can change the instruction being performed by changing the opcode of an instruction being executed, e.g. xxx. This is particularly troublesome if the two instructions take the same number of parameters and put the same number of elements back on the operand stack. If this is the case, the stack will have the same number of elements on it whether the original or the altered instruction is executed, and the same number of parameters. It can therefore not be detected with e.g. a countermeasure such as Field of Bit, which detects a change in an instruction if the number of parameters change~\cite[p. 16]{javasec}.
%modification of the JVM instruction set binary representation
This can partly be remedied by modifying the underlying binary representation of the instructions in the Java Card Virtual Machine (JCVM)\ch{should this be generalised to just virtual machine since it is universally true for all virtual machines?}.
%fewer instructions with same parameter number and hamming distance 1
This would work by changing the representation in such a way that as few as possible instructions with the same number of parameters, and the same number of elements returned to the stack, are different by one bit.
%fieldofbit usually implemented (source?)
%not complete protection against bitflips, but improves misalignment detection rates
%example table
