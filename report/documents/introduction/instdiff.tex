\subsection{Instruction Differentiation} 
A single bit flip can change the instruction being executed, e.g. \texttt{ifeq} can be flipped to \texttt{ifne}, \texttt{iflt}, \texttt{ifgt} and \texttt{goto} in the \jc bytecode instruction set. As mentioned in Field of Bit, this is particularly troublesome if the two instructions take the same number of parameters and put the same number of elements back on the operand stack. If this is the case, the operand stack will have the same number of elements on it regardless of whether the original or the altered instruction is executed, and the same number of parameters. It can therefore not be detected with e.g. a countermeasure such as Field of Bit, which detects a change in an instruction if the number of parameters change~\cite[p. 16]{javasec}.
%modification of the JVM instruction set binary representation
This can partly be remedied by modifying the underlying binary representations of the instructions in the Java Virtual Machine.
%fewer instructions with same parameter number and hamming distance 1
This would work by changing the representations in such a way, that as few as possible instructions with the same number of parameters, and the same number of elements returned to the operand stack, are different by one bit. 
%not complete protection against bitflips, but improves misalignment detection rates
When a single bit flip changes an instruction, the chances that it is an undetectable change, in regards to required parameters and elements put back on the operand stack by it, are smaller than before modifying the representations.

%example table