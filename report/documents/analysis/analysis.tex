\section{Program Analysis with Sawja}\label{sec:sawja}
% intro about Sawja
We use the tool \textit{Sawja} (Static Analysis Workshop for JAva)~\cite{sawja}, which relies on \textit{Javalib} to extract information from Java class files, and can create a call graph. Information from the graph can then be used to provide information for rewriting purposes, e.g. the call graph integrity countermeasure, described in \cref{sub:faultCounter}.\\\\
\cref{lst:javaorig} shows Java code where two classes are present, \texttt{A} and \texttt{B}. \texttt{B} inherits \texttt{A}, and both implement the method \texttt{bar()}. The implementation of the method that will be called depends on the boolean value \texttt{b}. When the compiled class file of this code is processed for a call graph by \textit{Sawja}, the result is as \cref{lst:callgraph} shows. The numbers that are listed just after the method calls, e.g. $40$ are interesting, since they cluster method call targets, which can not always be determined statically. In our case, we can use this to see which methods the call graph integrity countermeasure should be implemented in. If a method is not called, \textit{Sawja} does not include it in the call graph.
% clustering of possible methods
In the case with code where it is impossible to tell which method will be called at run-time as in \cref{lst:javaorig}, \textit{Sawja} includes both, as in line 3 and 4.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Java sample.,language=Java,label=lst:javaorig]
public void foo(boolean b){
    (b ? new A() : new B()).bar();
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth} %\ch{fix highlighting of number 40}
\begin{lstlisting}[caption=Call graph generated by \textit{Sawja}.,language=Java,label=lst:callgraph]
void Sample.main(java.lang.String[]),22 -> void B.<init>()
void Sample.main(java.lang.String[]),12 -> void A.<init>()
void Sample.main(java.lang.String[]),40 -> short A.bar()
void Sample.main(java.lang.String[]),40 -> short B.bar()
\end{lstlisting}
\end{minipage}

It is also able to pretty print the bytecode so that it becomes easier to read as in \cref{lst:javasawja}. 
% inlining of constant pool
The tool performs an inlining of the constant pool. This is evident in lines 7, 9, 12, 14 and 16. For example in line 7, \texttt{new A} would normally be \texttt{new \#id} where the id would be a method reference stored with identifier \texttt{id} in the constant pool. This inlining makes for a more compact representation of the bytecode. Additionally, dead code does not show up in \textit{Sawja}'s output.
% line numbers
Note that in the output, the target of a \texttt{goto} is expressed in terms of a relative offset as seen in line 11, and not a concrete program counter as in regular Java bytecode. The instruction in line 11 will jump to the instruction at program counter $21$.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Sawja sample. Note that the numbers on the inner left side are program counter values.,language=Java,label=lst:javasawja]
public void foo ( bool 1 ) ;
		Concrete Method
    	Not parsed

0.  iload 1
1.  ifeq 13
4.  new A
7.  dup
8.  invokespecial void A.<init> ( )
        A.<init>
11. goto 10
14. new B
17. dup
18. invokespecial void B.<init> ( )
        B.<init>
21. invokevirtual short A.bar ( )
        B.bar
        A.bar
24. pop
25. return

\end{lstlisting}
\end{minipage}
