\section{Program Analysis with Sawja}
% intro about Sawja
\ch{should we mention stackless presentations JBir and A3Bir?}
We use the tool \textit{Sawja} (Static Analysis Workshop for JAva)\cite{sawja}, which relies on \textit{Javalib}, to extract information from Java class files. The tool can analyse Java bytecode\ch{should we write Java or Java card bytecode?} and create a call graph, which we then use for rewriting purposes, described in\ch{ref}.\\\\
\cref{lst:javaorig} shows Java code where two classes are present, \texttt{A} and \texttt{B}. \texttt{B} inherits \texttt{A}, and both implement the method \texttt{bar()}. The implementation of the method that will be called depends on the boolean value \texttt{b}. When the compiled class file of this code is processed for a call graph by \textit{Sawja}, the result is as \cref{lst:javasawja} shows.\\\\
% line numbers
Note that in the output, the target of a \texttt{goto} is expressed in terms of a relative offset as seen in line 11, and not a concrete program counter as in regular Java bytecode. The instruction in line 11 will jump to the instruction at program counter $21$.
% inlining of constant pool


\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Java sample.,language=Java,label=lst:javaorig]
public void foo(boolean b){
    (b ? new A() : new B()).bar();
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Sawja sample. Note that the numbers on the inner left side are program counter values.,language=Java,label=lst:javasawja]
public void foo ( bool 1 ) ;
		Concrete Method
    	Not parsed

0.  iload 1
1.  ifeq 13
4.  new A
7.  dup
8.  invokespecial void A.<init> ( )
        A.<init>
11. goto 10
14. new B
17. dup
18. invokespecial void B.<init> ( )
        B.<init>
21. invokevirtual short A.bar ( )
        B.bar
        A.bar
24. pop
25. return

\end{lstlisting}
\end{minipage}